/********************************************************************

Author      Oliviero Taleghani
Date        2024-04-25

Description
  Part of the label package, responsible for adding to the qr_code
  image generated by qr_generator.go a printed description. It uses
  freetype to draw the text. The change is made in place, so this
  function will not return anything. 

Usage
  x := 1      // The x position of the label
  y := 1      // The y position of the label
  drawLabel(img, "the labal that you want to add", x, y)
  // img will contain the updated image

Dependency
  "github.com/golang/freetype"
  "github.com/golang/freetype/truetype"
  "golang.org/x/image/font"

Todo
  - [ ]     Error handling

Changelog
  [0.0.1]   2024-04-25
  Added     Initial release

*********************************************************************/

package label

import (
  "image"
  "github.com/golang/freetype"
  "github.com/golang/freetype/truetype"
  "golang.org/x/image/font"
  "os"
)

func drawLabel(img *image.RGBA, label string, x, y int) {
  fontSize := 20.0
  fontDPI := 200.0
  fontFamily := loadFont()

  c := freetype.NewContext()
  c.SetFont(fontFamily)
  c.SetDPI(fontDPI)
  c.SetFontSize(fontSize)
  c.SetClip(img.Bounds())
  c.SetDst(img)
  c.SetSrc(image.Black)
  // For interfacing with freetype you will need to create a
  // NewContext and add the different parameters, like the font in
  // use, the fontSize, the DPI, the clipping the destination image
  // and the image from where it should draw. This is because freetype
  // "clips" from a source image with the type.

  fontFace := truetype.NewFace(fontFamily, &truetype.Options{
    Size: fontSize,
    DPI: fontDPI,
    Hinting: font.HintingFull,
  })
  // We are even creating a NewFace to make some calculation
  // afterwords. Here we basically set the same settings of the
  // freetype version.

  textBoxWidth := (img.Bounds().Dx()/14)*9
  // Used to calculate the max width of the text box.

  wrappedText := wrapText(label, textBoxWidth, fontFace)
  // Returns a wrapped version of the text, calculated based on the
  // max width of the box, the fontFace in use and the label that we
  // want to print. Returns a []string

  for index, string := range wrappedText {
    pt := freetype.Pt(x, y+((index+1) * int(fontDPI / fontSize * 5)))
    _, err := c.DrawString(string, pt)
    if err != nil {
      panic(err)
    }
  }
  // Cycles throw the wrapped text, calculates the y axes based on the
  // text Size and DPI. Then it just prints the text on the image with
  // DrawString.
}

func wrapText(s string, maxWidth int, face font.Face) []string {
  currentWidth := 0
  // Keeps the current width of a list of characters
  currentString := ""
  // Keeps the current list of characters
  var strings []string
  // Holds the resulting divided strings

  for index, x := range s {
    charLenghtRaw, _ := face.GlyphAdvance(x) 
    charLenght := int(charLenghtRaw >> 6)
    // Here we are measuring the width taken by the current char in
    // the loop. We basically loop over every single character in the
    // string, we calculate the width of the characters, we add that
    // together and we compare the total width with the max width of
    // the text box (maxWidth int). 

    if currentWidth + charLenght > maxWidth {
      strings = append(strings, currentString)
      currentWidth = 0
      currentString = ""
    }
    // If current width + the character lenght overflows, we append
    // the current string and resent current width and string

    if len(currentString) == 0 && string(x) == " " {
      continue
    }
    // If after resetting the next string is a space, just continue

    currentWidth += charLenght
    currentString += string(x)
    // Add the char lenght and the char itself to the current

    if index == len(s) - 1 {
      strings = append(strings, currentString)
    }
    // If we are at the last character, just append the string as is
  }

  if len(strings) > 1 && len(strings[len(strings)-1]) == 1 {
    strings[len(strings)-2] += strings[len(strings)-1]
    strings = strings[:len(strings)-1]
  }
  // If there are more than one rows and the last row has only one
  // character, we then append that last row to the second to last row
  // and then we delete the last row.

  return strings
}

func loadFont() *truetype.Font {
  fontBytes, err := os.ReadFile("fonts/RobotoMono-Regular.ttf")
  if err != nil {
    panic(err)
  }

  f, err := truetype.Parse(fontBytes)
  if err != nil {
    panic(err)
  }

  return f
}
